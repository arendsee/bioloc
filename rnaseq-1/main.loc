@comment

The input to this pipeline is a list of SRA runids and their group:

SRR1914591      pathogenic
SRR1914590      pathogenic
SRR1914589      pathogenic
SRR1914585      non-pathogenic
SRR1914584      non-pathogenic
SRR1914583      non-pathogenic

RNA-seq steps

------ Setup -----------------------------
 * retrieve data
       [prefetch, fastq-dump]
 * trim and remove adaptors
       [trimmomatic] 

------ Initial QC ------------------------
 * QC on short reads
       [fastqc]
 * check genome assembly
       [assemblathon script]


------ Mapping ---------------------------
 * align to reference
       [tophat]
   * SV - how much of the genome is covered?
        - how many of the reads are mapped?

------ Reconstruction/quantification -----
 * assemble transcripts
       [cufflinkes . cuffmerge]
   * SV - how many transcripts are there?
        - how many genes are represented?
        - how active is splicing?
   * group transcripts by gene
 * count gene features
       [cufflinks | (gsnap,HTSeq)] 
   * SV

------ Comparison ------------------------
 * differential gene expression
       [edgeR,cuffdiff]
   * SV

Problems:

 1. In Bash, it is tricky to specify how formal inputs map to arguments. For
    example, in a function `foo :: A -> B -> C`, where `foo` in Bash has the
    form: `foo -a A -b B [options]`,  I need to map

    $\@ A B ---> $\@[-2] -a A -b B

    I need to remove the last two elements from the input argument vector and
    make them names parameters. And this is awkward ...

    If the positionals came first, I could just do:

    wrap_foo (){
       a=$1 ; shift
       b=$2 ; shift
       foo -a $a -b $b $\@
    }

 2. I should be able to attach checks and whatnot to groups (e.g. *quantify). I
    should also be able to set their type.

 3. conventions for languages vary, specifically, Haskell likes having the data
    last in order and the parameters or functions first. For example, a `select`
    function that extracts one column from a table, would in Haskell have the
    signature:
   
    Select :: Int -> Table -> [a]
   
    But in R would probably be
   
    Select :: Table -> Int -> [a]
   
    Data first in R is needed for magrittresque piping, whereas having the data
    last allows less variable things to be curried out in Haskell.


Manuals:

http://www.usadellab.org/cms/uploads/supplementary/Trimmomatic/TrimmomaticManual_V0.32.pdf

RNA-seq tutorials:

http://sparta-teaching.readthedocs.io/en/latest/rnaseqbackground.html

@path sh
main ::
    *quantify
    .
    *merge
    <map2:gtfs>
    .
    map:transcripts
    .
    &( *assemble . $1 ) map2:gtfs
    .
    &( *align . *genome_db $1 $2 ) map:clean_qs
    .
    &( *clean . $1 ) map:dirty_qs
    .
    &( *retrieve . $1 ) *runids

quantify     :: cuffdiff
merge        :: cuffmerge
assemble     :: cufflinks
align        :: tophat
genome_db    :: bowtie2-build . get_reference
clean        :: trimmomatic
retrieve     :: fastq-dump . prefetch
runids       :: nthcol . 1 *rnaseq_table
rnaseq_table :: 'data.tab'


@cache
* :: datcache

# @before
# bowtie2-build :: genome_stats . <get_reference>
#
# @assert
# # perm :: [(a -> Bool)] -> [a] -> [((a -> Bool), a)]
# # tophat :+ all . perm . [is_fastq, is_in_sequence_space] [$1, $2]
#
# tophat :+ equal_length . $1 $2


@arg
# arguments shared between all programs
tophat,cufflinks,cuffdiff :: --library-type fr-unstranded
tophat,cufflinks,cuffdiff,cuffmerge :: --num-threads 8

tophat    :: --solexa-quals -g 2
cufflinks :: -u
cuffdiff  :: -T -u

# Load sra archive into ncbi/public/sra folder
prefetch ::
    # maximum file to retrieve (G for gigabyte)
    --max-size `100G`
    # download protocol, first try ascp, on fail use http
    --transport `both`
    # double-check all refseqs
    --check-all

# unpack the sra file prefetch retrieves
fastq-dump ::
    # append read id (.1, .2) after spot id
    --readids
    # split paired-ends into files suffixed with _1 and _2
    --split-files
    # output as ACGT rather than color-base (e.g. SOLiD)
    --dumpbase
    # skip technical reads (not useable by Kallisto, also
    # is specific to Illumina multiplexing library
    # construction protocol)
    --skip-technical
    # remove left and right tags
    --clip
    # filter used in current 1000 genomes data
    --qual-filter-1

@include
core/tables

accessors
validators
wrappers

@source sh
map2 (){
    while read line
    do
        $1 "$2"
    done
}
